```go
func maxSubArray(nums []int) int {
	max := nums[0]
	len := len(nums)
	for i := 1; i < len; i++ {
		if nums[i]+nums[i-1] > nums[i] { // 这一步使我学到了遍历数组可以这样避免nums[len]的问题
			nums[i] += nums[i-1]
		}
		if nums[i] > max {
			max = nums[i]
		}
	}
	return max
}
```

这题通过看完解析和代码实现之后自己再写了一遍，用的是动态规划思想，第一次接触动态规划，使用了较长时间理解。

### 动态规划

其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

### 我对解题的理解

我们要求的是数组里面连续的数字之和最大值

第一个和第一加第二比较完，将结果抽象成一个新的*f*(*i*) (以第 i个数结尾的「连续子数组的最大和」，包含第i个)，而这个f(i)就是一个最小子问题的最优解，然后再将新的f(i)与下一个数进行比较，再把最小子问题的最优解抽象成一个f(i)，以此类推，在过程中取得问题的最优解

我们把抽象的子问题最优解定义为f(i-1)和下一个数nums[i]进行比较，这里是这样比较的（代码中用nums[i]储存了当前f(i)）：

​						if nums[i]+nums[i-1] > nums[i] {  // 这一步很好地比较了nums[i],num[i-1]和nums[i]+nums[i+1]的大小关系

​						     nums[i]  += nums[i-1]

​						}

我这里理解的意思是当前面的f(i)小于零了（这样子if条件成立），连续的数和就截止了，重新再以nums[i]开始为新的f(i);如果中间有f(i)>max,就可以赋值给max，直到遍历结束，这样就找到了问题最优解。（前面半句是我自己强行往细节理解的，其实可以不用考虑那么多，我们的每一步都是对比两个数，对比出来的都是上面比较的三个数(nums[i],num[i-1]和nums[i]+nums[i+1]的大小关系)中最大的

## 当有点领悟时最好看官方的解析，会比现在描述的更容易理解